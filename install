#!/usr/bin/env bash
#
# bootstrap installs things.

DOTFILES_ROOT="`pwd`"
PLUGINS_DIR="$DOTFILES_ROOT/plugins"
GENERATED_DIR="$DOTFILES_ROOT/generated"
DISABLED_PLUGINS_FILE="$GENERATED_DIR/.disabled_plugins"

set -e

echo ''

info () {
  printf "  [ \033[00;34m..\033[0m ] $1"
}

user () {
  printf "\r  [ \033[0;33m?\033[0m ] $1 "
}

success () {
  printf "\r\033[2K  [ \033[00;32mOK\033[0m ] $1\n"
}

fail () {
  printf "\r\033[2K  [\033[0;31mFAIL\033[0m] $1\n"
  echo ''
  exit
}

# Create generated directory if it doesn't exist
mkdir -p "$GENERATED_DIR"

# Create disabled plugins file if it doesn't exist
touch "$DISABLED_PLUGINS_FILE"

# Function to list all plugins and their status
list_plugins() {
  echo "Available plugins:"
  echo "----------------"
  
  # First list base plugin if it exists
  if [ -d "$PLUGINS_DIR/base" ]; then
    if grep -q "^base$" "$DISABLED_PLUGINS_FILE"; then
      echo "  base (disabled)"
    else
      echo "  base (active)"
    fi
  fi
  
  # Then list other plugins
  for plugin_dir in "$PLUGINS_DIR"/*; do
    if [ "$plugin_dir" != "$PLUGINS_DIR/base" ] && [ -d "$plugin_dir" ]; then
      plugin_name="$(basename "$plugin_dir")"
      if grep -q "^$plugin_name$" "$DISABLED_PLUGINS_FILE"; then
        echo "  $plugin_name (disabled)"
      else
        echo "  $plugin_name (active)"
      fi
    fi
  done
}

# Function to disable a plugin
disable_plugin() {
  local plugin="$1"
  
  # Check if plugin exists
  if [ ! -d "$PLUGINS_DIR/$plugin" ]; then
    fail "Plugin '$plugin' does not exist"
  fi
  
  # Check if plugin is already disabled
  if grep -q "^$plugin$" "$DISABLED_PLUGINS_FILE"; then
    echo "Plugin '$plugin' is already disabled"
    return
  fi
  
  # Add plugin to disabled list
  echo "$plugin" >> "$DISABLED_PLUGINS_FILE"
  success "Disabled plugin: $plugin"
}

# Function to enable a plugin
enable_plugin() {
  local plugin="$1"
  
  # Check if plugin exists
  if [ ! -d "$PLUGINS_DIR/$plugin" ]; then
    fail "Plugin '$plugin' does not exist"
  fi
  
  # Check if plugin is disabled
  if ! grep -q "^$plugin$" "$DISABLED_PLUGINS_FILE"; then
    echo "Plugin '$plugin' is already enabled"
    return
  fi
  
  # Remove plugin from disabled list
  sed -i "/^$plugin$/d" "$DISABLED_PLUGINS_FILE"
  success "Enabled plugin: $plugin"
}

# Function to check if a plugin is disabled
is_plugin_disabled() {
  local plugin="$1"
  grep -q "^$plugin$" "$DISABLED_PLUGINS_FILE"
}

# Function to get available plugins for autocomplete
_get_available_plugins() {
  local plugins=()
  for plugin_dir in "$PLUGINS_DIR"/*; do
    if [ -d "$plugin_dir" ]; then
      plugins+=("$(basename "$plugin_dir")")
    fi
  done
  echo "${plugins[@]}"
}

# Bash completion for --disable and --enable flags
_install_completion() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local prev="${COMP_WORDS[COMP_CWORD-1]}"
  
  case "$prev" in
    --disable|-d|--enable|-e)
      COMPREPLY=($(compgen -W "$(_get_available_plugins)" -- "$cur"))
      return 0
      ;;
  esac
  
  COMPREPLY=($(compgen -W "--list -l --disable -d --enable -e" -- "$cur"))
}

# Register completion
complete -F _install_completion ./install

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --list|-l)
      list_plugins
      exit 0
      ;;
    --disable|-d)
      if [ -z "$2" ]; then
        fail "Please specify a plugin to disable"
      fi
      disable_plugin "$2"
      exit 0
      ;;
    --enable|-e)
      if [ -z "$2" ]; then
        fail "Please specify a plugin to enable"
      fi
      enable_plugin "$2"
      exit 0
      ;;
    *)
      ;;
  esac
  shift
done

# Function to generate main bash configuration files
generate_bash_config () {
  local config_type="$1"  # e.g., bashrc, bash_aliases, bash_profile
  local main_file="$GENERATED_DIR/$config_type"
  
  # Create the main configuration file
  echo "# Generated by dotfiles installer - DO NOT EDIT DIRECTLY" > "$main_file"
  echo "# Edit the individual plugin files instead" >> "$main_file"
  echo "" >> "$main_file"
  
  # Export DOTFILES_ROOT for use in sourced files
  echo "# Set dotfiles root directory" >> "$main_file"
  echo "export DOTFILES_ROOT=\"$DOTFILES_ROOT\"" >> "$main_file"
  echo "" >> "$main_file"

  # For bashrc, add script directories to PATH
  if [ "$config_type" = "bashrc" ]; then
    echo "# Add plugin script directories to PATH" >> "$main_file"
    echo "# Base plugin scripts" >> "$main_file"
    echo 'if [ -d "$DOTFILES_ROOT/plugins/base/scripts" ]; then' >> "$main_file"
    echo '    PATH="$DOTFILES_ROOT/plugins/base/scripts:$PATH"' >> "$main_file"
    echo "fi" >> "$main_file"
    echo "" >> "$main_file"
    
    echo "# Other plugin scripts" >> "$main_file"
    echo 'for plugin_dir in "$DOTFILES_ROOT/plugins/"*; do' >> "$main_file"
    echo '    if [ "$plugin_dir" != "$DOTFILES_ROOT/plugins/base" ] && [ -d "$plugin_dir/scripts" ]; then' >> "$main_file"
    echo '        PATH="$plugin_dir/scripts:$PATH"' >> "$main_file"
    echo '    fi' >> "$main_file"
    echo "done" >> "$main_file"
    echo "" >> "$main_file"
  fi
  
  # First add base plugin if it exists and is not disabled
  if [ -d "$PLUGINS_DIR/base" ] && ! is_plugin_disabled "base"; then
    # Handle special cases for base plugin
    case "$config_type" in
      "bashrc")
        # Source Git completion and prompt scripts first
        if [ -f "$PLUGINS_DIR/base/git/git-completion.bash" ]; then
          echo "# Source Git completion" >> "$main_file"
          echo "if [ -f \"$PLUGINS_DIR/base/git/git-completion.bash\" ]; then" >> "$main_file"
          echo "    source \"$PLUGINS_DIR/base/git/git-completion.bash\"" >> "$main_file"
          echo "fi" >> "$main_file"
          echo "" >> "$main_file"
        fi
        
        if [ -f "$PLUGINS_DIR/base/git/git-prompt.bash" ]; then
          echo "# Source Git prompt" >> "$main_file"
          echo "if [ -f \"$PLUGINS_DIR/base/git/git-prompt.bash\" ]; then" >> "$main_file"
          echo "    source \"$PLUGINS_DIR/base/git/git-prompt.bash\"" >> "$main_file"
          echo "fi" >> "$main_file"
          echo "" >> "$main_file"
        fi
        
        # Source bashenv if it exists
        if [ -f "$PLUGINS_DIR/base/bashenv" ]; then
          echo "# Source base environment configuration" >> "$main_file"
          echo "if [ -f \"$PLUGINS_DIR/base/bashenv\" ]; then" >> "$main_file"
          echo "    source \"$PLUGINS_DIR/base/bashenv\"" >> "$main_file"
          echo "fi" >> "$main_file"
          echo "" >> "$main_file"
        fi
        ;;
      "bash_aliases")
        # Source alias.bash if it exists
        if [ -f "$PLUGINS_DIR/base/bash/alias.bash" ]; then
          echo "# Source base aliases" >> "$main_file"
          echo "if [ -f \"$PLUGINS_DIR/base/bash/alias.bash\" ]; then" >> "$main_file"
          echo "    source \"$PLUGINS_DIR/base/bash/alias.bash\"" >> "$main_file"
          echo "fi" >> "$main_file"
          echo "" >> "$main_file"
        fi
        ;;
    esac

    # Source any .symlink files
    for source in $(find "$PLUGINS_DIR/base" -maxdepth 2 -name "$config_type.symlink"); do
      if [ -f "$source" ]; then
        echo "# Source base plugin configuration" >> "$main_file"
        echo "if [ -f \"$source\" ]; then" >> "$main_file"
        echo "    source \"$source\"" >> "$main_file"
        echo "fi" >> "$main_file"
        echo "" >> "$main_file"
      fi
    done
  fi
  
  # Then add other plugins that are not disabled
  for plugin_dir in "$PLUGINS_DIR"/*; do
    if [ "$plugin_dir" != "$PLUGINS_DIR/base" ] && [ -d "$plugin_dir" ]; then
      local plugin_name="$(basename "$plugin_dir")"
      
      # Skip disabled plugins
      if is_plugin_disabled "$plugin_name"; then
        continue
      fi
      
      # Handle special cases for other plugins
      case "$config_type" in
        "bash_aliases")
          # Look for alias.bash in plugin
          if [ -f "$plugin_dir/bash/alias.bash" ]; then
            echo "# Source $plugin_name aliases" >> "$main_file"
            echo "if [ -f \"$plugin_dir/bash/alias.bash\" ]; then" >> "$main_file"
            echo "    source \"$plugin_dir/bash/alias.bash\"" >> "$main_file"
            echo "fi" >> "$main_file"
            echo "" >> "$main_file"
          fi
          ;;
      esac
      
      # Source any .symlink files
      for source in $(find "$plugin_dir" -maxdepth 2 -name "$config_type.symlink"); do
        if [ -f "$source" ]; then
          echo "# Source $plugin_name plugin configuration" >> "$main_file"
          echo "if [ -f \"$source\" ]; then" >> "$main_file"
          echo "    source \"$source\"" >> "$main_file"
          echo "fi" >> "$main_file"
          echo "" >> "$main_file"
        fi
      done
    fi
  done

  # Finally, source the prompt configuration last (for bashrc only)
  if [ "$config_type" = "bashrc" ] && ! is_plugin_disabled "base"; then
    if [ -f "$PLUGINS_DIR/base/prompt.bash" ]; then
      echo "# Source prompt configuration (last to override any other prompt settings)" >> "$main_file"
      echo "if [ -f \"$PLUGINS_DIR/base/prompt.bash\" ]; then" >> "$main_file"
      echo "    source \"$PLUGINS_DIR/base/prompt.bash\"" >> "$main_file"
      echo "fi" >> "$main_file"
      echo "" >> "$main_file"
    fi
  fi
  
  success "generated $main_file"
}

link_files () {
  ln -s "$1" "$2"
  success "linked $1 to $2"
}

process_symlinks () {
  local plugin_dir="$1"
  local plugin_name="$(basename "$plugin_dir")"
  
  # Skip if plugin is disabled
  if is_plugin_disabled "$plugin_name"; then
    return
  fi
  
  info "Processing symlinks for plugin: $plugin_name\n"

  for source in $(find "$plugin_dir" -maxdepth 2 -name \*.symlink)
  do
    local filename="$(basename "${source%.*}")"
    local dest="$HOME/.$filename"
    
    # Skip bash-related files as they're handled separately
    if [[ "$filename" == "bashrc" ]] || [[ "$filename" == "bash_aliases" ]] || [[ "$filename" == "bash_profile" ]]; then
      continue
    fi

    if [ -f "$dest" ] || [ -d "$dest" ]
    then
      overwrite=false
      backup=false
      skip=false

      if [ "$overwrite_all" == "false" ] && [ "$backup_all" == "false" ] && [ "$skip_all" == "false" ]
      then
        user "File already exists: $filename, what do you want to do? [s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all?"
        read -n 1 action

        case "$action" in
          o )
            overwrite=true;;
          O )
            overwrite_all=true;;
          b )
            backup=true;;
          B )
            backup_all=true;;
          s )
            skip=true;;
          S )
            skip_all=true;;
          * )
            ;;
        esac
      fi

      if [ "$overwrite" == "true" ] || [ "$overwrite_all" == "true" ]
      then
        rm -rf "$dest"
        success "removed $dest"
      fi

      if [ "$backup" == "true" ] || [ "$backup_all" == "true" ]
      then
        mv "$dest" "$dest.backup"
        success "moved $dest to $dest.backup"
      fi

      if [ "$skip" == "false" ] && [ "$skip_all" == "false" ]
      then
        link_files "$source" "$dest"
      else
        success "skipped $source"
      fi

    else
      link_files "$source" "$dest"
    fi
  done
}

run_plugin_install () {
  local plugin_dir="$1"
  local plugin_name="$(basename "$plugin_dir")"
  
  # Skip if plugin is disabled
  if is_plugin_disabled "$plugin_name"; then
    return
  fi
  
  local install_script="$plugin_dir/install.sh"
  
  if [ -f "$install_script" ]; then
    info "Running install script for plugin: $plugin_name\n"
    bash "$install_script"
  fi
}

install_plugins () {
  info 'Installing plugins\n'

  overwrite_all=false
  backup_all=false
  skip_all=false
  
  # Generate main bash configuration files
  generate_bash_config "bashrc"
  generate_bash_config "bash_aliases"
  generate_bash_config "bash_profile"
  
  # Link the generated files to home directory
  for config_file in "$GENERATED_DIR"/*; do
    if [ -f "$config_file" ]; then
      local filename="$(basename "$config_file")"
      local dest="$HOME/.$filename"
      
      # Backup existing file if it's not a symlink to our generated file
      if [ -f "$dest" ] && [ ! -L "$dest" ]; then
        mv "$dest" "$dest.backup"
        success "backed up $dest to $dest.backup"
      fi
      
      # Create or update symlink
      ln -sf "$config_file" "$dest"
      success "linked $config_file to $dest"
    fi
  done
  
  # Process other symlinks and install scripts
  # First base plugin if not disabled
  if [ -d "$PLUGINS_DIR/base" ] && ! is_plugin_disabled "base"; then
    process_symlinks "$PLUGINS_DIR/base"
    run_plugin_install "$PLUGINS_DIR/base"
  fi

  # Then other plugins that are not disabled
  for plugin_dir in "$PLUGINS_DIR"/*; do
    if [ "$plugin_dir" != "$PLUGINS_DIR/base" ] && [ -d "$plugin_dir" ]; then
      process_symlinks "$plugin_dir"
      run_plugin_install "$plugin_dir"
    fi
  done
}

# If no arguments provided, run the installation
if [ $# -eq 0 ]; then
  install_plugins

  echo ''
  echo '  All installed!'
  echo ''
  echo 'Plugin system is now set up. Available commands:'
  echo '  ./install --list, -l          List all plugins and their status'
  echo '  ./install --disable, -d       Disable a plugin'
  echo '  ./install --enable, -e        Enable a plugin'
  echo ''
  echo 'Base customizations are in plugins/base'
  echo 'Each plugin can contain:'
  echo '  - *.symlink files that will be linked to your home directory'
  echo '    - Bash-related files (bashrc, bash_aliases, bash_profile) remain in the plugin'
  echo '      and are sourced from generated configuration files'
  echo '    - Other *.symlink files are linked directly to your home directory'
  echo '  - An install.sh script for additional setup steps'
  echo ''
  
  # Reload the current shell environment
  echo 'Reloading shell environment...'
  if [ -f "$GENERATED_DIR/bashrc" ]; then
    # Export any environment variables that were in the old environment
    export -p > "$GENERATED_DIR/.temp_env"
    # Source the new bashrc
    source "$GENERATED_DIR/bashrc"
    # Restore old environment variables
    source "$GENERATED_DIR/.temp_env"
    rm -f "$GENERATED_DIR/.temp_env"
    echo 'Shell environment reloaded!'
  else
    echo 'Warning: Could not reload shell environment (bashrc not found)'
  fi
fi

